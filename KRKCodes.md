# Introduction #

In the codes section, you need to create:

  * A composition called KRK. (KRK in 3-letters ALLCAPS)
  * A text layer in KRK composition (name is not important here)
  * A text layer in your Karaoke composition, called KRK (ALLCAPS, just three letters)

Next, the codes can either be typed in:
Source Text
Source Text's Expression (make sure = is checked off, or it will generate an error)

You can also hide the KRK and text layer to avoid any errors.

The karaoke JSON data generated by Karaoke\_json.html is pasted into the text layer in KRK composition.  It can be inserted either in Source text's expression or Source text.  Since there's a limit to how much stuff you can fit into an expression, pasting in Source text is recommended.  If you paste in source text, your codes will go into source text's expressions, but if you paste in source text's expressions (for smaller karaoke), then your codes should go into source text.  JSON is a complete JavaScript expression, which means that it should not generate any errors in the expression.

There are two types of effects:
  * Line Effect: It's an effect for the entire line
  * Syllable Effect: It's an effect for the syllable.

# How to READ #

Fn( x [, y , z ] )
  * Fn is the function/method name you call by there.  If Fn has a DOT beforehand, it means that it will be called after some without a dot.
  * the brackets [ ] mean that y and z are optional
  * If I say y is optional, y can be undefined.
  * If I say z is an object, then you can use standard JSON expression to define what's in z.  For example: {syl: true, pos: true}.  This tells that z contains syl with a true value and pos with a true value.  i.e. z.syl = true, and z.pos = true.
  * If I say y is an array, then you can use standard JSON expression to define what's in y. For example: ["romaji" , "english" , "kanji" ](.md) means that y contains all of the following: 'romaji', 'english', and 'kanji'  In addition, y[0](0.md) is set to romaji, y[1](1.md) is set to english, and y[2](2.md) is set to kanji.
  * If I say y is a string, it contains only one value enclosed in quotes (double or single).  For example, "english" or 'kanji'.
  * If I say y is a Boolean, it contains only true or false in lower case.  For example: true
  * If I say y is a number, it contains only numbers.  For example: 10

# KRK Composition Codes #

This is the main codes.  It basically tells the script where to look.

## shift( x ) ##

Shifts the karaoke json by x seconds.  If you have x as a negative number, it will shift backward.  This is a global function to the Karaoke JSON you pasted.

## setFontSize( x [, styles] ) ##

set the font size "x" in pixels for different styles.  By default, it's normalized to one.

If `styles` is not set or undefined, then it sets to all of your styles
`styles` can be one style, defined as a string.  It can also be multiple styles, defined as an array.

## add( comp ) ##

Adds a composition with the name 'comp' into the autoamtions.  This will tell the script to look into comp.  The name is case-insensitive, and it will look for the first name it finds.

# KRK Text Layer codes #

This is the per-composition codes.  It basically tells the script what to do about the layers.  Note: In this section, all of the names are case-sensitive as well as space dependent.

## add( LayerName [, options ] ) ##

This adds a template layer with the name LayerName (Case-Sensitive) to the composition.  It returns a KRKLayer object.  Therefore, you can call the methods directly underneath this with .  For example: add( LayerName ).a( "Romaji" ).a( "Kanji" )

## .a( AnimatorName [, options ] ) ##

This adds an animator (with the name: AnimatorName) under Text Animator.  By default, it will add as a line effect.  The AnimatorName can be an ARRAY with multiple names.

### options ###

  * if options is a Boolean (true), it will set add the animators based on the syllable (true) rather than line (false/null/undefined).
  * If options is an object, it uses the following:
    * syl: Is it a syllable effect?
    * unnorm: String.  Can be "start" or "end".  This basically tells the script to do effects with unnormalized timings.  Start means it's at the starting syllable/line timing, and End means that it's at the ending syllable/line timing.

## .l( styles [, options ] ) ##

Generates the layers based on your styles and options.

  * styles is a list of styles.  It can be undefined (all styles), String (one style), or Array (more than one styles).
    * The format goes as follows: [StyleName , LayerNumber , LineNumber , SyllableNumber ](.md).
    * Each part corresponds to the definition in your .ass.  That is, StyleName is the name of your style, LayerNumber is the layer number defined after Dialogue: , LineNumber is the line number of your karaoke in that style, and Syllable number is the syllable in that line.
    * Each part can be an array to allow multiple karaoke selectors.  For example: [["Romaji" , "Kanji"]]

### options ###
  * If option is undefined, it will generate per line.
  * If options is a Boolean, true, it will generate syllable per layer (true) instead of line per layer (false/null/undefined)
  * If options is an object, the following will be used.
    * syl: Is it layer per syllable generator?
    * 2: Yep, it's the number two.  It generates the secondary style with a new line next to the first style.  So you'll get two lines with the first one primary style and the second line style "2".  You will need to provide a style there as a String.  It only works for one style.
    * unnorm: String.  Can be "start" or "end".  This basically tells the script to do effects with unnormalized timings.  Start means it's at the starting syllable/line timing, and End means that it's at the ending syllable/line timing.


## .p( PropertyName [, options ] ) ##

  * PropertyName is a string that can be obtained from the expression of a property.  By default, Adobe After-Effects will display the name in the expression field.

Note: If there are children properties under PropertyName, it will search through all the children and use the children with the keyframes with the current options.
For example, if you have linear wipe, fast blur, and nothing else under Effects, and you want to apply the effects as syllable transition, use the following command:

.p( "effects" , true )

### options ###

  * If options is a Boolean (true), it will add the animators based on the syllable (true) rather than line (false/null/undefined).
  * If options is an object, it will use the following:
    * syl: Is it a sylalble effect?
    * unnorm: String.  Can be "start" or "end".  This basically tells the script to do effects with unnormalized timings.  Start means it's at the starting syllable/line timing, and End means that it's at the ending syllable/line timing.
    * pos: Dump the positional data from your syllables or lines into the properties if pos: true.  It's by default normalized from 0 (beginning of the syllable or line) to 100 (end of the syllable or line).  If this is a number (200), it will normalize to that number instead of 100.

## .s( AFXPropertyName , Property , value ) ##

This basically sets the AFXPropertyName (name from expression in your layer's property) with a property and a value.  For example: .s( "layerStyle" , "enabled" , false ).

### special cases ###
when value = undefine, you can set the layer's property value.
Example: .s('enabled', false) -- to hide the layer.

when property ='layer', you can assign the generated layers to the property.